
fonction_recursive()

if(robbot.treasure_found)
    demi_tour();
    avancer();
    return;

while(robot.orientation != corridor.orientation)
    tourner_90_horaire();

avancer();

corridor.node = node(robot.get_couleur())

if(corridor.node.color == cul_de_sac)
    demi_tour();
    avancer();
    return;

else if(corridor.node.color == carrefour)
    corridor.node.corrdidors = get_corridor()
    for(corridors)
        fonctionn_recursive();
    
else if(corridor.node.color == )




Informations et objectifs du projet

Travailler sur l'orienté objet
travail sur le robot,
objectif utiliser les classes, lire la documentation et savoir utiliser les classes fournis
Premier compte rendu sur la séance 2, pour préparer les séances de tps.

Evaluation : cr à la fin de la séance 2
Updaté à chaque séance, et versionné.
Note sur l'organisation des tps, savoir si on sait bien communiquer, travailler en groupe.
Le code n'est pas noté mais le code doit fonctionner.
Deux exercices, et si ça fonctionne alors c'est bon.
A la fin du test,


Deux capteurs dont un capteur de couleurs

objectif explorere le labyrinthe pour trouver le trésor.
Exercice 2 : ressortir par le chemin le plus cours

Sur la démo finale, le labyrinthe sera changé
Que modifier dans l'algorithme pour gérer les boucles ?

si gomette bleu -> embranchement, gomette vert : cul de sac ; gomette jaune : trésor
Pas de courbes, lignes droites noire

Gérer le fait que le robot ne peut pas précisement tourner ou alors avancer droit.


longueurs d'au moins 15cm

difficulté du projet → Il faut donc faire du travail de groupe

s'organiser dans une démarche projet.

Faire un chef de projet qui doit tourner, mais pas qui lead dans l'objectif de s'assurer que tout le monde suit bien et qu'il s'assure que tout le monde travaille bien


Faire un diagramme de Gant →liste des taches à faire et à quel moment on les fait.

Il faut donc faire un brainstorming pour savoir ce que l'on a à faire. (gérer les moteurs, les capteurs, tourner...);

voir pour faire des taches avant les tps.
faire des binomes/monomes en parallèles pour aller plus vite.

e.g : faire un algorithme.

Objectif bien prévoir mais ne pas surprévoir, mettre à jour le diagramme de Gant après la réalisation des tâches.

Quand peut-on dire que l'on a fini une tache ? →quand on l'a testée.

Rapport de 5 pages maximum avec le diagramme de Gant et la description de tous les algorithmes utilisés.

Penser aux classes. Avoir un algorithme/programme qui ressemble à un algorithme.

e.g pour se souvenir d'un itinéraire, se souvenir de tou → de quelles classes avons nous besoins ?

L'organisation du groupe.

Utilisation uniquement du capteur de couleur pour regarder ce qu'il y a au sol

il regardera devant (possibilité d'utiliser ça pour détecter la ligne)

attention faire attention à ce que


utiliser l'écran pour savoir ce que le robot fait



Utilisation d'éclipse. → en Java on est obligé de faire des classes pour tout. Plus de fonctions etc...



utiliser LEJOS → API codé en JAVA pour programmer le robot.

Pour l'algorithme papier le décomposer suffisament pour pouvoir le programmer

capterus de couleurs pas sur la documentation de l'API mais près sur light sensor.


utilisation des classes motors et color sensor


Que les directions est ouest nord sud, dans les limites de 